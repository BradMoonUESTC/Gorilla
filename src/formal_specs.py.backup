"""
Formal specification definitions - define invariants and pre/post-conditions smart contracts should satisfy
"""

from typing import Dict, List, Any
from dataclasses import dataclass


@dataclass
class Invariant:
    """Invariant definition"""
    name: str
    description: str
    condition: str  # Solidity condition expression
    violation_check: str  # Assertion for violation checks


@dataclass
class PreCondition:
    """Pre-condition definition"""
    function_name: str
    condition: str
    description: str


@dataclass
class PostCondition:
    """Post-condition definition"""
    function_name: str
    condition: str
    description: str


class FormalSpecGenerator:
    """Formal specification generator"""
    
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.invariants = self._define_erc20_invariants()
        self.pre_conditions = self._define_erc20_pre_conditions()
        self.post_conditions = self._define_erc20_post_conditions()
    
    def _define_erc20_invariants(self) -> List[Invariant]:
        """Define invariants for ERC20 contracts"""
        return [
            Invariant(
                name="total_supply_conservation",
                description="Total token supply should equal the sum of all account balances",
                condition="token.totalSupply() == _sumAllBalances()",
                violation_check="assertEq(token.totalSupply(), _sumAllBalances(), 'Total supply invariant violated')"
            ),
            Invariant(
                name="balance_non_negative",
                description="All account balances must be non-negative",
                condition="token.balanceOf(account) >= 0",
                violation_check="assertTrue(token.balanceOf(attacker) >= 0 && token.balanceOf(victim) >= 0, 'Balance non-negative invariant violated')"
            ),
            Invariant(
                name="allowance_consistency",
                description="Allowance should not increase without authorization",
                condition="allowance can only decrease or be reset",
                violation_check="assertTrue(token.allowance(victim, attacker) <= initialAllowance, 'Allowance consistency invariant violated')"
            ),
            Invariant(
                name="unauthorized_mint_prevention",
                description="Only authorized users can mint tokens",
                condition="mint operations require proper authorization",
                violation_check="assertTrue(token.balanceOf(attacker) == 0 || attackerWasAuthorized, 'Unauthorized mint prevention invariant violated')"
            ),
            Invariant(
                name="contract_eth_balance_safety",
                description="Contract ETH balance should not be withdrawn without authorization",
                condition="contract ETH balance should not decrease without authorization",
                violation_check="assertTrue(address(token).balance >= expectedMinBalance, 'Contract ETH balance safety invariant violated')"
            )
        ]
    
    def _define_erc20_pre_conditions(self) -> List[PreCondition]:
        """Define pre-conditions for ERC20 functions"""
        return [
            PreCondition(
                function_name="transfer",
                condition="balanceOf[msg.sender] >= amount",
                description="Sender balance must be sufficient before transfer"
            ),
            PreCondition(
                function_name="transferFrom", 
                condition="balanceOf[from] >= amount && allowance[from][msg.sender] >= amount",
                description="Balance and allowance must be sufficient before delegated transfer"
            ),
            PreCondition(
                function_name="withdraw",
                condition="balanceOf[msg.sender] > 0",
                description="There must be a token balance before withdrawing"
            )
        ]
    
    def _define_erc20_post_conditions(self) -> List[PostCondition]:
        """Define post-conditions for ERC20 functions"""
        return [
            PostCondition(
                function_name="transfer",
                condition="balanceOf[to] == old(balanceOf[to]) + amount && balanceOf[from] == old(balanceOf[from]) - amount",
                description="Balances should update correctly after transfer"
            ),
            PostCondition(
                function_name="transferFrom",
                condition="allowance[from][msg.sender] == old(allowance[from][msg.sender]) - amount",
                description="Allowance should decrease after delegated transfer"
            ),
            PostCondition(
                function_name="mint",
                condition="totalSupply == old(totalSupply) + amount && balanceOf[to] == old(balanceOf[to]) + amount",
                description="Total supply and target balance should increase after minting"
            ),
            PostCondition(
                function_name="withdraw",
                condition="balanceOf[msg.sender] == 0 && address(this).balance == old(address(this).balance) - amount",
                description="After withdraw, user balance is zeroed and contract ETH decreases"
            )
        ]
    
    def get_invariants_for_test(self, vulnerability_type: str = None) -> List[Invariant]:
        """Get invariants for testing"""
        if vulnerability_type == "unauthorized_mint":
            return [inv for inv in self.invariants if inv.name in ["unauthorized_mint_prevention", "total_supply_conservation"]]
        elif vulnerability_type == "allowance_bypass":
            return [inv for inv in self.invariants if inv.name in ["allowance_consistency", "balance_non_negative"]]
        elif vulnerability_type == "reentrancy":
            return [inv for inv in self.invariants if inv.name in ["contract_eth_balance_safety", "balance_non_negative"]]
        else:
            return self.invariants[:3]  # Return the first 3 most important invariants


