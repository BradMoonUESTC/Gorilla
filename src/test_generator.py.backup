"""
Test generator - Generate Solidity test code based on natural language input
"""

import os
import sys
from pathlib import Path
from typing import Dict, Any

# æ·»åŠ openai_apiåˆ°è·¯å¾„
openai_api_path = os.path.join(os.path.dirname(__file__), 'openai_api')
sys.path.append(openai_api_path)
from openai_api.openai import ask_openai_common

from template_system import (
    read_base_template,
    generate_test_code,
    create_default_template_variables
)
from formal_specs import FormalSpecGenerator
from spec_violation_detector import SpecViolationDetector


class TestGenerator:
    """Test code generator"""
    
    def __init__(self, project_path: str):
        self.project_path = project_path
        self.spec_generator = FormalSpecGenerator(project_path)
        self.violation_detector = SpecViolationDetector(project_path)
        
    def generate_test_from_description(self, description: str) -> str:
        """Generate test code from a natural language description. Supports two modes: direct exploit and spec violation detection"""
        
        # 1. Read base template
        try:
            template_code = read_base_template(self.project_path)
        except FileNotFoundError as e:
            print(f"Error: {e}")
            return ""
        
        # 2. Determine test mode
        test_mode = self._determine_test_mode(description)
        print(f"ðŸŽ¯ Test mode: {test_mode}")
        
        if test_mode == "spec_violation":
            # Spec violation detection mode
            variables = self._generate_spec_violation_test(description, template_code)
        else:
            # Direct exploit mode
            variables = self._generate_exploit_test(description, template_code)
        
        # 3. Generate test code
        test_code = generate_test_code(template_code, variables)
        
        # 4. Replace class name
        test_code = test_code.replace("GorillaBaseTest", "GorillaTest")
        
        return test_code
    
    def _generate_test_variables(self, description: str, template_code: str) -> Dict[str, str]:
        """Use the LLM to generate template variables - focused on exploit testing"""
        
        # Read contract code for context
        contract_code = self._read_contract_code()
        
        prompt = f"""
Choose and call the appropriate exploit helper based on the testing requirement.

Testing requirement: {description}

Available helpers:
- _testUnauthorizedMint() (for access-control/mint-related tests)
- _testAllowanceBypass() (for allowance/transferFrom-related tests)
- _testReentrancyAttack() (for reentrancy/withdraw-related tests)
- _testIntegerOverflow() (for integer overflow-related tests)

Answer strictly in the following format, with nothing else added:

testLogic: _testUnauthorizedMint();
vulnerabilityAssertions: assertTrue(token.balanceOf(attacker) > attackerBalanceBefore, "Unauthorized mint attack failed");

If it is an allowance-related test:
testLogic: _testAllowanceBypass();
vulnerabilityAssertions: assertTrue(token.balanceOf(attacker) > attackerBalanceBefore, "Allowance bypass attack failed");

If it is a reentrancy-related test:
testLogic: _testReentrancyAttack();
vulnerabilityAssertions: assertTrue(address(token).balance < contractEthBefore, "Reentrancy attack failed");

Now choose the appropriate function call based on the testing requirement "{description}":"""
        
        try:
            print("ðŸ¤– Prompt sent to the LLM:")
            print("-" * 40)
            print(prompt)
            print("-" * 40)
            
            response = ask_openai_common(prompt)
            
            print("ðŸ¤– LLM response:")
            print("-" * 40)
            print(response)
            print("-" * 40)
            
            return self._parse_llm_response(response)
        except Exception as e:
            print(f"LLM call failed: {e}")
            return create_default_template_variables()
    
    def _parse_llm_response(self, response: str) -> Dict[str, str]:
        """Parse the LLM response to extract template variables"""
        variables = create_default_template_variables()
        
        # Simple parsing logic - handle only testLogic and vulnerabilityAssertions
        lines = response.split('\n')
        
        for line in lines:
            line = line.strip()
            if line.startswith('testLogic:'):
                content = line.replace('testLogic:', '').strip()
                if content:
                    variables['testLogic'] = content
            elif line.startswith('vulnerabilityAssertions:'):
                content = line.replace('vulnerabilityAssertions:', '').strip()
                if content:
                    variables['vulnerabilityAssertions'] = content
        
        return variables
    
    def _read_contract_code(self) -> str:
        """Read target contract code"""
        try:
            contract_path = Path(self.project_path) / "src" / "SimpleERC20.sol"
            if contract_path.exists():
                with open(contract_path, 'r', encoding='utf-8') as f:
                    return f.read()
            else:
                return "// Contract file does not exist"
        except Exception as e:
            return f"// Failed to read contract: {e}"
    
    def _determine_test_mode(self, description: str) -> str:
        """Determine the test mode: direct exploit vs. spec violation detection"""
        description_lower = description.lower()
        
        # Keyword-based determination of spec violation mode
        spec_keywords = [
            "invariant", "invariants", "specification", "specifications",
            "pre-condition", "precondition", "post-condition", "postcondition",
            "violation", "formal"
        ]
        
        if any(keyword in description_lower for keyword in spec_keywords):
            return "spec_violation"
        else:
            return "exploit"
    
    def _generate_exploit_test(self, description: str, template_code: str) -> Dict[str, str]:
        """Generate a direct exploit test"""
        return self._generate_test_variables(description, template_code)
    
    def _generate_spec_violation_test(self, description: str, template_code: str) -> Dict[str, str]:
        """Generate a spec violation detection test"""
        
        # 1. Identify vulnerability type
        vulnerability_type = self._identify_vulnerability_type(description)
        print(f"ðŸ” Identified vulnerability type: {vulnerability_type}")
        
        # 2. Detect specification violations
        contract_code = self._read_contract_code()
        print("ðŸ“‹ Analyzing contract code...")
        violation_info = self.violation_detector.detect_spec_violations(vulnerability_type, contract_code)
        print(f"ðŸ“‹ Specification violation analysis complete, vulnerability type: {vulnerability_type}")
        
        if violation_info['has_violations']:
            print(f"âš ï¸  Detected spec violations: {len(violation_info['violations'])}")
            for i, violation in enumerate(violation_info['violations'], 1):
                print(f"   {i}. {violation['reason']}")
        else:
            print("âœ… No obvious spec violations detected")
        
        # 3. Generate spec violation test code
        return self._generate_spec_based_test_variables(vulnerability_type, violation_info)
    
    def _identify_vulnerability_type(self, description: str) -> str:
        """Identify the vulnerability type"""
        description_lower = description.lower()
        
        if 'mint' in description_lower or 'unauthorized' in description_lower or 'access control' in description_lower:
            return 'unauthorized_mint'
        elif 'allowance' in description_lower or 'transferfrom' in description_lower:
            return 'allowance_bypass'
        elif 'reentrancy' in description_lower or 'reentrant' in description_lower or 'withdraw' in description_lower:
            return 'reentrancy'
        elif 'overflow' in description_lower or 'unchecked' in description_lower:
            return 'integer_overflow'
        else:
            return 'unauthorized_mint'  # default type
    
    def _generate_spec_based_test_variables(self, vulnerability_type: str, violation_info: Dict) -> Dict[str, str]:
        """Generate test variables based on spec violations"""
        
        # Get related invariants
        invariants = violation_info['invariants_to_check']
        
        # Generate test logic based on vulnerability type and spec violations
        test_logic_map = {
            'unauthorized_mint': '_testUnauthorizedMint();',
            'allowance_bypass': '_testAllowanceBypass();',
            'reentrancy': '_testReentrancyAttack();',
            'integer_overflow': '_testIntegerOverflow();'
        }
        
        # Generate assertions for spec violation checks
        invariant_checks = []
        for inv in invariants:
            invariant_checks.append(inv.violation_check)
        
        # Combine assertions
        combined_assertions = '\n        '.join(invariant_checks)
        
        # If spec violations are detected, add details
        if violation_info['has_violations']:
            violation = violation_info['violations'][0]
            comment = f"// Detected spec violation: {violation['specification']}\n        // Reason: {violation['reason']}\n        "
            test_logic = comment + test_logic_map.get(vulnerability_type, '_testUnauthorizedMint();')
        else:
            test_logic = test_logic_map.get(vulnerability_type, '_testUnauthorizedMint();')
        
        return {
            'testLogic': test_logic,
            'vulnerabilityAssertions': combined_assertions
        }
